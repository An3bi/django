======================
The form rendering API
======================

.. versionadded:: 1.11

Django form widgets are rendered using the Django template backend system.

The form rendering process can be customized at several levels:

* Widgets can specify custom template names.
* Forms and widgets can specify custom renderer classes.
* Built-in templates can be overridden within a project or application.

.. _low-level-widget-render-api:

The low-level render API
========================

Widget templates are stored in the ``django/forms/widgets`` path. A project
can provide a custom template for ``input.html`` by defining
``django/forms/widgets/input.html``, for example.

The rendering of form templates is controlled by a customizable renderer class.
A custom renderer can be specified by updating the :setting:`FORM_RENDERER`
setting. It defaults to
``'``:class:`django.forms.renderers.templates.DjangoTemplateRenderer`\ ``'``.

.. module:: django.forms.renderers.templates

.. class:: BaseTemplateRenderer

The base class for the :ref:`built-in template form renderers
<built-in-template-form-renderers>`.

.. method:: BaseTemplateRenderer.get_template(template_name)

    If you don't override ``render()``, this method must be implemented.
    Given a template name, it should return
    a :class:`~django.template.Template` object or raise
    :exc:`~django.template.TemplateDoesNotExist`.

.. method:: BaseTemplateRenderer.render(template_name, context, request=None)

    Renders the ``template_name`` with ``context``. Calls
    :meth:`.get_template` to load the given ``template_name``.

    If you implement a custom renderer, this is the only method that Django
    calls and therefore that you must implement. :meth:`get_template` is
    called by ``BaseTemplateRenderer.render()``, but custom renderers
    don't need to follow this pattern.

.. class:: EngineRendererMixin

    Simplifies defining custom renderers that use a custom template engine.

.. method:: EngineRendererMixin.get_template(template_name)

    Requires an ``engine`` property to be defined on the renderer and calls
    ``self.engine.get_template(template_name)`` to render the template.

    For example, if you wanted to use a custom Jinja2 template engine, you
    could create your own custom renderer subclass like this::

        from django.forms.renderers.templates import (
            BaseTemplateRenderer, EngineRendererMixin,
        )
        from django.template.backends.jinja2 import Jinja2
        from django.utils.functional import cached_property

        class MyRenderer(EngineRendererMixin, BaseTemplateRenderer):

            @cached_property
            def engine(self):
                return Jinja2({
                    'APP_DIRS': False,
                    'DIRS': ['/path/to/templates/'],
                    'NAME': 'djangoforms',
                    'OPTIONS': {},
                })

.. _built-in-template-form-renderers:

Built-in-template form renderers
================================

``DjangoTemplateRenderer``
--------------------------

.. class:: DjangoTemplateRenderer

This renderer uses a :class:`~django.template.backends.django.DjangoTemplates`
engine. It loads templates first from the application directories and then from
the built-in form templates directory in ``django/forms``.

``Jinja2TemplateRenderer``
--------------------------

.. class:: Jinja2TemplateRenderer

This renderer is the same as :class:`DjangoTemplateRenderer` except that it
uses a :class:`~django.template.backends.jinja2.Jinja2` backend.

To use this backend, all the widgets in your project and its third-party apps
must have Jinja2 templates. You can't use this renderer, for example, if you're
using :mod:`django.contrib.admin` because Jinja2 templates aren't included for
the admin widgets due to their usage of Django template tags.

``ProjectTemplateRenderer``
---------------------------

.. class:: ProjectTemplateRenderer

This renderer gives you complete control of how widget templates are sourced.
It uses :func:`~django.template.loader.get_template` to find widget
templates based on what's configured in the :setting:`TEMPLATES` setting.

Using the renderer along with the built-in widget templates requires either:

#. ``'django.forms'`` in :setting:`INSTALLED_APPS` and at least one engine
   with ``APP_DIRS=True``.

#. Adding the built-in widgets templates directory (``django/forms/templates``
   or ``django/forms/jinja2``) in ``DIRS`` of one of your template engines.

You've chosen to take full control, so it's your responsibility to make
the form templates you need can be located.

Customizing widget rendering
============================

Form widgets are rendered using the renderer specified by the
:setting:`FORM_RENDERER` setting. This gives you full control of widget output.

Each widget has a ``template_name`` attribute, such as
``'django/forms/widgets/textarea.html'``. See :ref:`built-in widgets` for the
name of each widget's template.

When rendered, the template receives a context from
:meth:`.Widget.get_context`. By default, widgets receive a single value in the
context, ``widget``. This is a dictionary that contains values like:

* ``name``
* ``value``
* ``attrs``
* ``is_hidden``
* ``template_name``

Some widgets add further information to the context. For instance, all widgets
that subclass ``Input`` defines ``widget['type']`` and :class:`.MultiWidget`
defines ``widget['subwidgets']`` for looping purposes.

Overriding widget templates works the same as overriding other templates. The
:class:`ProjectTemplateRenderer` uses
:func:`~django.template.loader.get_template` to find a template.

Overriding the renderer per form
================================

You can provide a custom render by setting the :attr:`.Form.default_renderer`
attribute or by using the ``renderer`` argument of :meth:`.Widget.render`.
